<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>高级五子棋AI系统</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f5f5f5;
            margin: 0;
            padding: 20px;
        }
        h1 {
            color: #333;
            margin-bottom: 10px;
        }
        .controls {
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            max-width: 1000px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            background-color: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.1);
        }
        .control-group h3 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 14px;
            color: #555;
        }
        button, select, input {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
        }
        button:hover {
            background-color: #45a049;
        }
        button.secondary {
            background-color: #f0f0f0;
            color: #333;
        }
        button.secondary:hover {
            background-color: #e0e0e0;
        }
        button.warning {
            background-color: #ff9800;
            color: white;
        }
        button.warning:hover {
            background-color: #e68a00;
        }
        #board-container {
            background-color: #DEB887;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.2);
            margin-bottom: 20px;
            position: relative;
        }
        #board {
            display: grid;
            grid-template-columns: repeat(15, 30px);
            grid-template-rows: repeat(15, 30px);
            gap: 1px;
            background-color: #DEB887;
            background-image: 
                linear-gradient(to right, #8B4513 1px, transparent 1px),
                linear-gradient(to bottom, #8B4513 1px, transparent 1px);
            background-size: 30px 30px;
        }
        .cell {
            width: 30px;
            height: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            position: relative;
            z-index: 1;
        }
        .black {
            width: 24px;
            height: 24px;
            background-color: black;
            border-radius: 50%;
            box-shadow: 0 0 3px rgba(0,0,0,0.5);
        }
        .white {
            width: 24px;
            height: 24px;
            background-color: white;
            border-radius: 50%;
            box-shadow: 0 0 3px rgba(0,0,0,0.5);
        }
        .last-move {
            box-shadow: 0 0 5px 2px rgba(255, 215, 0, 0.7);
        }
        .debug-panel {
            display: flex;
            width: 100%;
            max-width: 1200px;
            margin-top: 20px;
            gap: 20px;
        }
        .debug-info {
            flex: 1;
            background-color: white;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.1);
            max-height: 500px;
            overflow-y: auto;
        }
        .training-log {
            flex: 1;
            background-color: white;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.1);
            max-height: 500px;
            overflow-y: auto;
        }
        .command-interface {
            flex: 0.5;
            background-color: white;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.1);
            max-height: 500px;
            display: flex;
            flex-direction: column;
        }
        #commandOutput {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 10px;
            border: 1px solid #ddd;
            padding: 5px;
            font-family: monospace;
            background-color: #f8f8f8;
        }
        #commandInput {
            width: 100%;
            padding: 8px;
            box-sizing: border-box;
            font-family: monospace;
        }
        .score-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            font-size: 12px;
        }
        .score-table th, .score-table td {
            border: 1px solid #ddd;
            padding: 5px;
            text-align: center;
        }
        .score-table th {
            background-color: #f2f2f2;
        }
        .hidden {
            display: none;
        }
        #status {
            margin: 10px 0;
            font-weight: bold;
            min-height: 20px;
            color: #333;
        }
        .training-progress {
            width: 100%;
            margin-top: 10px;
        }
        progress {
            width: 100%;
        }
        .log-entry {
            margin-bottom: 5px;
            padding-bottom: 5px;
            border-bottom: 1px solid #eee;
            font-size: 13px;
        }
        .log-entry.win {
            color: #4CAF50;
        }
        .log-entry.loss {
            color: #F44336;
        }
        .log-entry.draw {
            color: #FF9800;
        }
        .move-history {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 10px;
        }
        .move-history button {
            padding: 2px 5px;
            font-size: 12px;
        }
        .center-point {
            position: absolute;
            width: 6px;
            height: 6px;
            background-color: #8B4513;
            border-radius: 50%;
            z-index: 0;
        }
        .cursor {
            position: absolute;
            width: 30px;
            height: 30px;
            border: 2px solid red;
            z-index: 2;
            pointer-events: none;
            box-sizing: border-box;
        }
        .rule-editor {
            width: 100%;
            height: 100px;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <h1>高级五子棋AI系统</h1>
    
    <div class="controls">
        <div class="control-group">
            <h3>游戏控制</h3>
            <button id="newGame">新游戏</button>
            <button id="undoMove" class="warning" title="撤销上一步">悔棋</button>
            <select id="firstPlayer">
                <option value="human">玩家先手</option>
                <option value="ai">AI先手</option>
            </select>
        </div>
        
        <div class="control-group">
            <h3>AI设置</h3>
            <select id="aiLevel">
                <option value="1">初级AI</option>
                <option value="2" selected>中级AI</option>
                <option value="3">高级AI</option>
                <option value="4">专家AI</option>
            </select>
            <button id="toggleDebug">隐藏AI思考</button>
        </div>
        
        <div class="control-group">
            <h3>游戏规则</h3>
            <select id="gameRule">
                <option value="standard">标准规则</option>
                <option value="rif">RIF规则</option>
                <option value="yamaguchi">山口规则</option>
                <option value="swap1">一手交换</option>
                <option value="custom">自定义规则</option>
            </select>
            <div id="customRuleContainer" class="hidden">
                <textarea id="customRuleEditor" class="rule-editor" placeholder="输入自定义规则..."></textarea>
            </div>
        </div>
        
        <div class="control-group">
            <h3>AI训练</h3>
            <div style="display: flex; gap: 5px;">
                <input id="trainGames" type="number" min="1" max="1000" value="10" style="width: 60px;">
                <button id="startTraining">开始训练</button>
            </div>
            <button id="clearData" class="secondary">清除学习数据</button>
        </div>
        
        <div class="control-group">
            <h3>AI对战</h3>
            <div style="display: flex; gap: 5px;">
                <input id="aiBattleGames" type="number" min="1" max="1000" value="10" style="width: 60px;">
                <button id="startAIBattle">AI对战</button>
            </div>
            <div style="font-size: 12px; margin-top: 5px;">
                <span id="ai1Wins">AI1: 0</span> | 
                <span id="ai2Wins">AI2: 0</span> | 
                <span id="aiDraws">平局: 0</span>
            </div>
        </div>
    </div>
    
    <div id="status">游戏准备中...</div>
    <div id="board-container">
        <div id="board"></div>
        <div id="cursor" class="cursor hidden"></div>
    </div>
    
    <div class="debug-panel">
        <div id="debugInfo" class="debug-info">
            <h3>AI思考过程</h3>
            <div id="aiThinking"></div>
            <table class="score-table">
                <thead>
                    <tr>
                        <th>位置</th>
                        <th>进攻分</th>
                        <th>防守分</th>
                        <th>总分</th>
                        <th>模式</th>
                    </tr>
                </thead>
                <tbody id="scoreDetails">
                </tbody>
            </table>
        </div>
        
        <div class="command-interface">
            <h3>命令行</h3>
            <div id="commandOutput"></div>
            <input id="commandInput" type="text" placeholder="输入命令 (如: goto A1, chess B2)" />
        </div>
        
        <div id="trainingLog" class="training-log">
            <h3>训练日志</h3>
            <div id="logEntries"></div>
            <div class="move-history" id="moveHistory"></div>
        </div>
    </div>

    <script>
        // 游戏状态
        const gameState = {
            board: Array(15).fill().map(() => Array(15).fill(0)), // 0=空, 1=黑, 2=白
            currentPlayer: 1, // 1=黑, 2=白
            gameOver: false,
            lastMove: null,
            moveHistory: [], // 走棋历史记录
            boardHistory: [], // 棋盘历史记录
            learningData: JSON.parse(localStorage.getItem('gomokuLearningData')) || {
                wins: [],
                losses: [],
                aiBattleStats: { ai1Wins: 0, ai2Wins: 0, draws: 0 },
                patternWeights: { // 模式权重学习
                    OPEN_FOUR: 10000,
                    HALF_OPEN_FOUR: 5000,
                    OPEN_THREE: 2000,
                    HALF_OPEN_THREE: 500,
                    OPEN_TWO: 200,
                    HALF_OPEN_TWO: 50,
                    OPEN_ONE: 10,
                    HALF_OPEN_ONE: 1
                },
                deepLearning: {} // 深度学习模型数据
            },
            debugMode: true, // 默认显示思考过程
            isTraining: false,
            isAIBattle: false,
            trainingQueue: 0,
            aiBattlePlayers: [], // 记录对战AI的玩家
            cursorPosition: { row: 7, col: 7 }, // 命令行光标位置
            currentRule: 'standard', // 当前规则
            ruleSteps: [], // 规则步骤
            restrictedMoves: [], // 限制走棋位置
            swapAvailable: false, // 一手交换是否可用
            swapRequested: false // 是否请求交换
        };

        // 模式定义（使用学习到的权重）
        const PATTERNS = {
            FIVE: { score: 100000, name: '五连' },
            OPEN_FOUR: { 
                score: gameState.learningData.patternWeights.OPEN_FOUR, 
                name: '活四',
                type: 'OPEN_FOUR'
            },
            HALF_OPEN_FOUR: { 
                score: gameState.learningData.patternWeights.HALF_OPEN_FOUR, 
                name: '冲四',
                type: 'HALF_OPEN_FOUR'
            },
            OPEN_THREE: { 
                score: gameState.learningData.patternWeights.OPEN_THREE, 
                name: '活三',
                type: 'OPEN_THREE'
            },
            HALF_OPEN_THREE: { 
                score: gameState.learningData.patternWeights.HALF_OPEN_THREE, 
                name: '眠三',
                type: 'HALF_OPEN_THREE'
            },
            OPEN_TWO: { 
                score: gameState.learningData.patternWeights.OPEN_TWO, 
                name: '活二',
                type: 'OPEN_TWO'
            },
            HALF_OPEN_TWO: { 
                score: gameState.learningData.patternWeights.HALF_OPEN_TWO, 
                name: '眠二',
                type: 'HALF_OPEN_TWO'
            },
            OPEN_ONE: { 
                score: gameState.learningData.patternWeights.OPEN_ONE, 
                name: '活一',
                type: 'OPEN_ONE'
            },
            HALF_OPEN_ONE: { 
                score: gameState.learningData.patternWeights.HALF_OPEN_ONE, 
                name: '眠一',
                type: 'HALF_OPEN_ONE'
            }
        };

        // 方向向量
        const DIRECTIONS = [
            { dr: 1, dc: 0 },  // 垂直
            { dr: 0, dc: 1 },   // 水平
            { dr: 1, dc: 1 },   // 对角线
            { dr: 1, dc: -1 }   // 反对角线
        ];

        // 初始化棋盘
        function initBoard() {
            const boardElement = document.getElementById('board');
            boardElement.innerHTML = '';
            
            // 添加中心点标记
            const centerPoint = document.createElement('div');
            centerPoint.className = 'center-point';
            centerPoint.style.left = '222px'; // 15*30/2 - 3
            centerPoint.style.top = '222px';
            boardElement.appendChild(centerPoint);
            
            // 添加星位标记（天元和四个角星）
            const starPoints = [
                {row: 3, col: 3}, {row: 3, col: 11}, 
                {row: 7, col: 7}, 
                {row: 11, col: 3}, {row: 11, col: 11}
            ];
            
            starPoints.forEach(point => {
                const star = document.createElement('div');
                star.className = 'center-point';
                star.style.left = `${point.col * 30 - 3}px`;
                star.style.top = `${point.row * 30 - 3}px`;
                boardElement.appendChild(star);
            });
            
            for (let r = 0; r < 15; r++) {
                for (let c = 0; c < 15; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    
                    cell.addEventListener('click', () => handleCellClick(r, c));
                    
                    boardElement.appendChild(cell);
                }
            }
            
            updateBoardDisplay();
            updateCursorPosition();
        }

        // 更新光标位置
        function updateCursorPosition() {
            const cursor = document.getElementById('cursor');
            cursor.style.left = `${gameState.cursorPosition.col * 30}px`;
            cursor.style.top = `${gameState.cursorPosition.row * 30}px`;
            cursor.classList.remove('hidden');
        }

        // 处理点击事件
        function handleCellClick(row, col) {
            if (gameState.isTraining || gameState.isAIBattle || 
                gameState.gameOver || 
                (gameState.currentPlayer !== 1 && document.getElementById('firstPlayer').value === 'human') || 
                gameState.board[row][col] !== 0) {
                return;
            }
            
            // 检查是否是限制走棋位置
            if (isMoveRestricted(row, col)) {
                addCommandOutput(`位置 ${String.fromCharCode(65 + col)}${15 - row} 被规则限制`);
                return;
            }
            
            makeMove(row, col, gameState.currentPlayer);
            
            if (!gameState.gameOver) {
                if (gameState.swapAvailable && gameState.moveHistory.length === 1) {
                    // 一手交换规则下，玩家可以请求交换
                    gameState.swapRequested = confirm("你想要交换棋子颜色吗?");
                    if (gameState.swapRequested) {
                        swapPlayers();
                    }
                    gameState.swapAvailable = false;
                }
                
                setTimeout(() => aiMove(), 100);
            }
        }

        // 检查走棋是否被限制
        function isMoveRestricted(row, col) {
            return gameState.restrictedMoves.some(move => 
                (move.from && move.from.row === row && move.from.col === col) ||
                (move.to && row >= Math.min(move.from.row, move.to.row) && 
                          row <= Math.max(move.from.row, move.to.row) && 
                          col >= Math.min(move.from.col, move.to.col) && 
                          col <= Math.max(move.from.col, move.to.col))
            );
        }

        // 交换玩家
        function swapPlayers() {
            // 交换棋盘上的棋子
            for (let r = 0; r < 15; r++) {
                for (let c = 0; c < 15; c++) {
                    if (gameState.board[r][c] === 1) {
                        gameState.board[r][c] = 2;
                    } else if (gameState.board[r][c] === 2) {
                        gameState.board[r][c] = 1;
                    }
                }
            }
            
            // 更新历史记录
            gameState.moveHistory.forEach(move => {
                move.player = move.player === 1 ? 2 : 1;
            });
            
            // 更新当前玩家
            gameState.currentPlayer = gameState.currentPlayer === 1 ? 2 : 1;
            
            addCommandOutput("玩家已交换棋子颜色");
            updateBoardDisplay();
        }

        // 执行落子
        function makeMove(row, col, player) {
            // 保存当前棋盘状态到历史记录
            gameState.boardHistory.push(JSON.parse(JSON.stringify(gameState.board)));
            gameState.moveHistory.push({ row, col, player });
            updateMoveHistoryDisplay();
            
            gameState.board[row][col] = player;
            gameState.lastMove = { row, col, player };
            gameState.currentPlayer = player === 1 ? 2 : 1;
            
            // 应用规则限制
            applyRuleRestrictions(row, col);
            
            updateBoardDisplay();
            
            if (checkWin(row, col, player)) {
                gameState.gameOver = true;
                const winner = player === 1 ? '黑棋' : '白棋';
                const winnerName = (player === 1 && document.getElementById('firstPlayer').value === 'human') || 
                                 (player === 2 && document.getElementById('firstPlayer').value === 'ai') ? 
                                 '玩家' : 'AI';
                document.getElementById('status').textContent = `${winnerName}(${winner}) 获胜!`;
                
                // 记录学习数据
                if (!gameState.isTraining && !gameState.isAIBattle) {
                    if ((player === 2 && document.getElementById('firstPlayer').value === 'human') || 
                        (player === 1 && document.getElementById('firstPlayer').value === 'ai')) {
                        // AI赢了
                        gameState.learningData.wins.push({
                            board: JSON.parse(JSON.stringify(gameState.board)),
                            moves: [...gameState.moveHistory]
                        });
                        if (gameState.learningData.wins.length > 100) {
                            gameState.learningData.wins.shift();
                        }
                        adjustPatternWeights(true); // 根据胜利调整权重
                    } else { // 玩家赢了
                        gameState.learningData.losses.push({
                            board: JSON.parse(JSON.stringify(gameState.board)),
                            moves: [...gameState.moveHistory]
                        });
                        if (gameState.learningData.losses.length > 100) {
                            gameState.learningData.losses.shift();
                        }
                        adjustPatternWeights(false); // 根据失败调整权重
                    }
                    saveLearningData();
                }
            } else if (isBoardFull()) {
                gameState.gameOver = true;
                document.getElementById('status').textContent = '平局!';
                
                if (gameState.isAIBattle) {
                    gameState.learningData.aiBattleStats.draws++;
                    updateAIBattleStats();
                }
            }
        }

        // 应用规则限制
        function applyRuleRestrictions(row, col) {
            if (gameState.currentRule === 'rif') {
                // RIF规则：黑棋第一手必须下在天元，第二手必须下在周围3x3区域
                if (gameState.moveHistory.length === 1 && gameState.currentPlayer === 2) {
                    // 白棋第二手限制在3x3区域
                    const center = {row: 7, col: 7};
                    gameState.restrictedMoves = [{
                        from: {row: center.row - 1, col: center.col - 1},
                        to: {row: center.row + 1, col: center.col + 1}
                    }];
                } else if (gameState.moveHistory.length === 2 && gameState.currentPlayer === 1) {
                    // 黑棋第三手限制不在对称位置
                    const firstBlack = gameState.moveHistory[0];
                    const firstWhite = gameState.moveHistory[1];
                    
                    // 计算对称位置
                    const symmetricRow = 2 * firstWhite.row - firstBlack.row;
                    const symmetricCol = 2 * firstWhite.col - firstBlack.col;
                    
                    if (symmetricRow >= 0 && symmetricRow < 15 && symmetricCol >= 0 && symmetricCol < 15) {
                        gameState.restrictedMoves = [{
                            from: {row: symmetricRow, col: symmetricCol},
                            to: {row: symmetricRow, col: symmetricCol}
                        }];
                    }
                } else {
                    gameState.restrictedMoves = [];
                }
            } else if (gameState.currentRule === 'yamaguchi') {
                // 山口规则：类似RIF但有更多限制
                if (gameState.moveHistory.length === 0 && gameState.currentPlayer === 1) {
                    // 黑棋第一手必须下在天元
                    gameState.restrictedMoves = [{
                        from: {row: 0, col: 0},
                        to: {row: 14, col: 14},
                        without: {row: 7, col: 7}
                    }];
                }
                // 其他限制类似RIF...
            } else if (gameState.currentRule === 'swap1') {
                // 一手交换规则
                if (gameState.moveHistory.length === 0 && gameState.currentPlayer === 1) {
                    // 黑棋第一手限制
                    gameState.restrictedMoves = [{
                        from: {row: 4, col: 4},
                        to: {row: 10, col: 10}
                    }];
                    gameState.swapAvailable = true;
                } else {
                    gameState.restrictedMoves = [];
                }
            } else if (gameState.currentRule === 'custom') {
                // 自定义规则
                applyCustomRules();
            } else {
                // 标准规则无限制
                gameState.restrictedMoves = [];
            }
        }

        // 应用自定义规则
        function applyCustomRules() {
            const customRules = document.getElementById('customRuleEditor').value.split('\n');
            gameState.restrictedMoves = [];
            
            for (let i = 0; i < Math.min(customRules.length, gameState.moveHistory.length + 1); i++) {
                const rule = customRules[i].trim();
                if (!rule) continue;
                
                // 解析规则
                if (rule.startsWith('without')) {
                    const parts = rule.split(' ');
                    if (parts.length >= 2) {
                        const pos = parsePosition(parts[1]);
                        if (pos) {
                            gameState.restrictedMoves.push({
                                from: pos,
                                to: pos
                            });
                        }
                    }
                } else if (rule.includes('to')) {
                    const [fromPart, toPart] = rule.split('to');
                    const fromPos = parsePosition(fromPart.trim());
                    const toPos = parsePosition(toPart.trim());
                    if (fromPos && toPos) {
                        gameState.restrictedMoves.push({
                            from: fromPos,
                            to: toPos
                        });
                    }
                } else {
                    const pos = parsePosition(rule);
                    if (pos) {
                        gameState.restrictedMoves.push({
                            from: pos,
                            to: pos
                        });
                    }
                }
            }
        }

        // 解析位置字符串 (如 "A1" 或 "H8")
        function parsePosition(posStr) {
            if (!posStr || posStr.length < 2) return null;
            
            const colChar = posStr[0].toUpperCase();
            const col = colChar.charCodeAt(0) - 'A'.charCodeAt(0);
            const row = 15 - parseInt(posStr.slice(1));
            
            if (col >= 0 && col < 15 && row >= 0 && row < 15) {
                return {row, col};
            }
            return null;
        }

        // 悔棋功能
        function undoMove() {
            if (gameState.isTraining || gameState.isAIBattle || 
                gameState.moveHistory.length === 0 || 
                (gameState.moveHistory.length === 1 && document.getElementById('firstPlayer').value === 'ai')) {
                return;
            }
            
            // 至少保留一步棋（如果是AI先手）
            const minMoves = document.getElementById('firstPlayer').value === 'ai' ? 1 : 0;
            if (gameState.moveHistory.length <= minMoves) return;
            
            // 移除最后一步
            gameState.moveHistory.pop();
            gameState.boardHistory.pop();
            
            // 恢复棋盘状态
            if (gameState.boardHistory.length > 0) {
                gameState.board = JSON.parse(JSON.stringify(gameState.boardHistory[gameState.boardHistory.length - 1]));
            } else {
                gameState.board = Array(15).fill().map(() => Array(15).fill(0));
            }
            
            // 更新游戏状态
            gameState.gameOver = false;
            gameState.currentPlayer = gameState.moveHistory.length % 2 === 0 ? 1 : 2;
            gameState.lastMove = gameState.moveHistory.length > 0 ? 
                gameState.moveHistory[gameState.moveHistory.length - 1] : null;
            
            // 重新应用规则限制
            applyRuleRestrictions(gameState.lastMove?.row || 7, gameState.lastMove?.col || 7);
            
            document.getElementById('status').textContent = gameState.currentPlayer === 1 ? 
                '你的回合(黑棋)' : 'AI思考中...';
            
            updateBoardDisplay();
            updateMoveHistoryDisplay();
        }

        // 更新走棋历史显示
        function updateMoveHistoryDisplay() {
            const moveHistoryElement = document.getElementById('moveHistory');
            moveHistoryElement.innerHTML = '';
            
            gameState.moveHistory.forEach((move, index) => {
                const moveBtn = document.createElement('button');
                moveBtn.className = 'secondary';
                moveBtn.textContent = `${index + 1}. ${String.fromCharCode(65 + move.col)}${15 - move.row}`;
                moveBtn.title = `${move.player === 1 ? '黑棋' : '白棋'}走这里`;
                moveBtn.addEventListener('click', () => revertToMove(index));
                moveHistoryElement.appendChild(moveBtn);
            });
        }

        // 回退到指定步数
        function revertToMove(moveIndex) {
            if (gameState.isTraining || gameState.isAIBattle) return;
            
            // 更新历史记录
            gameState.moveHistory = gameState.moveHistory.slice(0, moveIndex + 1);
            gameState.boardHistory = gameState.boardHistory.slice(0, moveIndex + 1);
            
            // 恢复棋盘状态
            gameState.board = JSON.parse(JSON.stringify(gameState.boardHistory[moveIndex]));
            
            // 更新游戏状态
            gameState.gameOver = false;
            gameState.currentPlayer = (moveIndex + 1) % 2 === 0 ? 1 : 2;
            gameState.lastMove = gameState.moveHistory[moveIndex];
            
            // 重新应用规则限制
            applyRuleRestrictions(gameState.lastMove.row, gameState.lastMove.col);
            
            document.getElementById('status').textContent = gameState.currentPlayer === 1 ? 
                '你的回合(黑棋)' : 'AI思考中...';
            
            updateBoardDisplay();
            updateMoveHistoryDisplay();
        }

        // 调整模式权重（学习功能）
        function adjustPatternWeights(isWin) {
            const learningRate = 0.1; // 学习率
            const gamesToAnalyze = isWin ? 
                gameState.learningData.wins.slice(-10) : 
                gameState.learningData.losses.slice(-10);
            
            gamesToAnalyze.forEach(game => {
                // 分析获胜/失败方的模式出现频率
                const patternCounts = {
                    OPEN_FOUR: 0,
                    HALF_OPEN_FOUR: 0,
                    OPEN_THREE: 0,
                    HALF_OPEN_THREE: 0,
                    OPEN_TWO: 0,
                    HALF_OPEN_TWO: 0,
                    OPEN_ONE: 0,
                    HALF_OPEN_ONE: 0
                };
                
                // 统计获胜/失败方的模式
                const player = isWin ? 2 : 1; // 获胜方是AI(2)，失败方是玩家(1)
                game.moves.forEach(move => {
                    if (move.player === player) {
                        const patterns = getPatternsAt(move.row, move.col, player, true);
                        patterns.forEach(pattern => {
                            if (patternCounts.hasOwnProperty(pattern.type)) {
                                patternCounts[pattern.type]++;
                            }
                        });
                    }
                });
                
                // 调整权重
                Object.keys(patternCounts).forEach(type => {
                    const change = patternCounts[type] * learningRate * (isWin ? 1 : -1);
                    gameState.learningData.patternWeights[type] = Math.max(1, 
                        gameState.learningData.patternWeights[type] + change);
                    
                    // 更新PATTERNS中的权重
                    if (PATTERNS[type]) {
                        PATTERNS[type].score = gameState.learningData.patternWeights[type];
                    }
                });
            });
        }

        // AI走棋（增强版，避免"瞎走"）
        function aiMove() {
            if (gameState.gameOver || gameState.currentPlayer !== 2) return;
            
            const aiLevel = parseInt(document.getElementById('aiLevel').value);
            let move;
            
            // 确保AI不会在已有棋子的位置落子
            const isValidMove = (move) => {
                if (!move) return false;
                if (gameState.board[move.row][move.col] !== 0) return false;
                return !isMoveRestricted(move.row, move.col);
            };
            
            // 尝试找到最佳走棋，最多尝试5次
            let attempts = 0;
            do {
                if (aiLevel === 1) {
                    move = findRandomMove();
                } else if (aiLevel === 2) {
                    move = findBestMove(2);
                } else if (aiLevel === 3) {
                    move = findBestMove(2, true); // 使用深度搜索
                } else {
                    move = findDeepLearningMove(2); // 专家级使用深度学习
                }
                attempts++;
            } while (!isValidMove(move) && attempts < 5);
            
            // 如果还是无效，随机找一个有效空位
            if (!isValidMove(move)) {
                const emptyCells = getValidMoves();
                if (emptyCells.length > 0) {
                    move = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                }
            }
            
            if (move && isValidMove(move)) {
                makeMove(move.row, move.col, 2);
            }
            
            // 如果是AI对战模式，继续下一步
            if (gameState.isAIBattle && !gameState.gameOver) {
                setTimeout(() => aiMove(), 100);
            }
        }

        // 获取所有有效走棋位置
        function getValidMoves() {
            const emptyCells = [];
            for (let r = 0; r < 15; r++) {
                for (let c = 0; c < 15; c++) {
                    if (gameState.board[r][c] === 0 && !isMoveRestricted(r, c)) {
                        emptyCells.push({ row: r, col: c });
                    }
                }
            }
            return emptyCells;
        }

        // 随机走棋（初级AI，增强版）
        function findRandomMove() {
            const emptyCells = getValidMoves();
            if (emptyCells.length === 0) return null;
            
            // 优先选择中心区域
            const centerCells = emptyCells.filter(cell => {
                const distToCenter = Math.sqrt(Math.pow(cell.row - 7, 2) + Math.pow(cell.col - 7, 2));
                return distToCenter < 5;
            });
            
            const candidates = centerCells.length > 0 ? centerCells : emptyCells;
            return candidates[Math.floor(Math.random() * candidates.length)];
        }

        // 寻找最佳走棋（中级/高级AI，增强版）
        function findBestMove(player, advanced = false) {
            const opponent = player === 1 ? 2 : 1;
            const emptyCells = getValidMoves();
            
            if (emptyCells.length === 0) {
                return findRandomMove();
            }
            
            let bestScore = -Infinity;
            let bestMoves = [];
            const scores = [];
            
            // 评估每个空位的分数
            for (const cell of emptyCells) {
                const { row, col } = cell;
                
                let offensiveScore = 0;
                let defensiveScore = 0;
                
                // 进攻分数（如果AI在此落子）
                offensiveScore = evaluatePosition(row, col, player);
                
                // 防守分数（如果对手在此落子）
                defensiveScore = evaluatePosition(row, col, opponent);
                
                // 总分 = 进攻分 + 防守分 * 0.8 (防守稍弱于进攻)
                const totalScore = offensiveScore + defensiveScore * 0.8;
                
                // 记录评分详情用于调试
                scores.push({
                    position: `${String.fromCharCode(65 + col)}${15 - row}`,
                    row,
                    col,
                    offensiveScore,
                    defensiveScore,
                    totalScore,
                    patterns: getPatternsAt(row, col, player, true).map(p => p.name).join(', ')
                });
                
                // 更新最佳走棋
                if (totalScore > bestScore) {
                    bestScore = totalScore;
                    bestMoves = [{ row, col }];
                } else if (totalScore === bestScore) {
                    bestMoves.push({ row, col });
                }
            }
            
            // 显示调试信息
            displayDebugInfo(scores, bestScore);
            
            // 如果有多个最佳选择，优先选择中心附近的
            if (bestMoves.length > 1) {
                bestMoves.sort((a, b) => {
                    const distA = Math.sqrt(Math.pow(a.row - 7, 2) + Math.pow(a.col - 7, 2));
                    const distB = Math.sqrt(Math.pow(b.row - 7, 2) + Math.pow(b.col - 7, 2));
                    return distA - distB;
                });
            }
            
            // 高级AI会考虑更深的搜索
            if (advanced && bestScore < PATTERNS.FIVE.score / 2) {
                // 如果没有立即获胜或防守的必要，进行更深的搜索
                const deepMove = findDeepMove(player, 2); // 搜索深度为2
                if (deepMove) {
                    return deepMove;
                }
            }
            
            return bestMoves.length > 0 ? bestMoves[0] : null;
        }

        // 深度学习走棋（专家级AI）
        function findDeepLearningMove(player) {
            // 如果有学习数据，使用学习到的模式
            if (gameState.learningData.deepLearning && Object.keys(gameState.learningData.deepLearning).length > 0) {
                // 这里可以添加更复杂的深度学习模型推理
                // 简化版：结合学习到的模式和当前棋盘状态
                return findBestMove(player, true);
            }
            
            // 如果没有学习数据，使用高级搜索
            return findBestMove(player, true);
        }

        // 深度搜索（高级AI）
        function findDeepMove(player, depth) {
            if (depth === 0) return null;
            
            const opponent = player === 1 ? 2 : 1;
            const emptyCells = getValidMoves();
            
            // 限制搜索范围以提高性能
            const candidates = emptyCells.slice(0, 15);
            
            let bestScore = -Infinity;
            let bestMove = null;
            
            for (const cell of candidates) {
                const { row, col } = cell;
                
                // 模拟落子
                gameState.board[row][col] = player;
                
                // 检查是否直接获胜
                if (checkWin(row, col, player)) {
                    gameState.board[row][col] = 0; // 撤销模拟
                    return { row, col };
                }
                
                // 评估对手的最佳回应
                let opponentBestScore = -Infinity;
                const opponentEmptyCells = getValidMoves();
                
                for (const oppCell of opponentEmptyCells) {
                    const oppScore = evaluatePosition(oppCell.row, oppCell.col, opponent);
                    if (oppScore > opponentBestScore) {
                        opponentBestScore = oppScore;
                    }
                }
                
                // 计算净得分
                const currentScore = evaluatePosition(row, col, player) - opponentBestScore * 0.7;
                
                // 递归搜索
                if (depth > 1) {
                    const deepMove = findDeepMove(player, depth - 1);
                    if (deepMove) {
                        const deepScore = evaluatePosition(deepMove.row, deepMove.col, player);
                        if (deepScore > currentScore) {
                            gameState.board[row][col] = 0; // 撤销模拟
                            continue;
                        }
                    }
                }
                
                if (currentScore > bestScore) {
                    bestScore = currentScore;
                    bestMove = { row, col };
                }
                
                gameState.board[row][col] = 0; // 撤销模拟
            }
            
            return bestMove;
        }

        // 评估某个位置的分数（增强版）
        function evaluatePosition(row, col, player) {
            if (gameState.board[row][col] !== 0) return -Infinity;
            
            let totalScore = 0;
            const patterns = [];
            
            // 检查四个方向
            for (const dir of DIRECTIONS) {
                const pattern = getPattern(row, col, player, dir.dr, dir.dc);
                patterns.push(pattern);
                totalScore += pattern.score;
            }
            
            // 特殊模式加分（如双活三、活四+活三等）
            if (patterns.filter(p => p.type === 'OPEN_FOUR').length >= 1) {
                totalScore += PATTERNS.OPEN_FOUR.score * 0.5; // 额外加分
            }
            if (patterns.filter(p => p.type === 'OPEN_THREE').length >= 2) {
                totalScore += PATTERNS.OPEN_THREE.score * 1.5; // 双活三加分
            }
            if (patterns.filter(p => p.type === 'HALF_OPEN_FOUR').length >= 2) {
                totalScore += PATTERNS.HALF_OPEN_FOUR.score * 1.2; // 双冲四加分
            }
            
            // 中心位置加分（开局时更重要）
            const centerDist = Math.sqrt(Math.pow(row - 7, 2) + Math.pow(col - 7, 2));
            const centerBonus = 20 / (1 + centerDist);
            totalScore += centerBonus;
            
            // 深度学习调整分数（如果有）
            if (gameState.learningData.deepLearning) {
                // 这里可以添加深度学习模型的分数调整
                // 简化版：根据历史数据调整
                const positionKey = `${row},${col},${player}`;
                if (gameState.learningData.deepLearning[positionKey]) {
                    totalScore *= gameState.learningData.deepLearning[positionKey];
                }
            }
            
            return totalScore;
        }

        // 获取某个位置的所有模式（返回完整模式对象）
        function getPatternsAt(row, col, player, returnObjects = false) {
            const patterns = [];
            
            for (const dir of DIRECTIONS) {
                const pattern = getPattern(row, col, player, dir.dr, dir.dc);
                if (returnObjects) {
                    patterns.push(pattern);
                } else {
                    patterns.push(pattern.name);
                }
            }
            
            return patterns;
        }

        // 获取特定方向的模式
        function getPattern(row, col, player, dr, dc) {
            // 模拟落子
            gameState.board[row][col] = player;
            
            let maxLength = 1;
            let openEnds = 0;
            
            // 检查正方向
            let length = 1;
            let r = row + dr;
            let c = col + dc;
            let blocked = false;
            
            while (length < 5 && r >= 0 && r < 15 && c >= 0 && c < 15) {
                if (gameState.board[r][c] === player) {
                    length++;
                    r += dr;
                    c += dc;
                } else {
                    if (gameState.board[r][c] === 0) openEnds++;
                    blocked = true;
                    break;
                }
            }
            
            if (!blocked && r >= 0 && r < 15 && c >= 0 && c < 15) {
                if (gameState.board[r][c] === 0) openEnds++;
            } else if (!blocked) {
                // 到达棋盘边缘
            }
            
            // 检查反方向
            r = row - dr;
            c = col - dc;
            blocked = false;
            
            while (length < 5 && r >= 0 && r < 15 && c >= 0 && c < 15) {
                if (gameState.board[r][c] === player) {
                    length++;
                    r -= dr;
                    c -= dc;
                } else {
                    if (gameState.board[r][c] === 0) openEnds++;
                    blocked = true;
                    break;
                }
            }
            
            if (!blocked && r >= 0 && r < 15 && c >= 0 && c < 15) {
                if (gameState.board[r][c] === 0) openEnds++;
            } else if (!blocked) {
                // 到达棋盘边缘
            }
            
            maxLength = Math.max(maxLength, length);
            
            // 撤销模拟落子
            gameState.board[row][col] = 0;
            
            // 确定模式
            if (maxLength >= 5) {
                return PATTERNS.FIVE;
            } else if (maxLength === 4) {
                if (openEnds >= 2) return PATTERNS.OPEN_FOUR;
                if (openEnds >= 1) return PATTERNS.HALF_OPEN_FOUR;
            } else if (maxLength === 3) {
                if (openEnds >= 2) return PATTERNS.OPEN_THREE;
                if (openEnds >= 1) return PATTERNS.HALF_OPEN_THREE;
            } else if (maxLength === 2) {
                if (openEnds >= 2) return PATTERNS.OPEN_TWO;
                if (openEnds >= 1) return PATTERNS.HALF_OPEN_TWO;
            } else if (maxLength === 1) {
                if (openEnds >= 2) return PATTERNS.OPEN_ONE;
                if (openEnds >= 1) return PATTERNS.HALF_OPEN_ONE;
            }
            
            return { score: 0, name: '无', type: 'NONE' };
        }

        // 检查是否获胜
        function checkWin(row, col, player) {
            for (const dir of DIRECTIONS) {
                let count = 1;
                
                // 正方向
                let r = row + dir.dr;
                let c = col + dir.dc;
                while (r >= 0 && r < 15 && c >= 0 && c < 15 && gameState.board[r][c] === player) {
                    count++;
                    r += dir.dr;
                    c += dir.dc;
                }
                
                // 反方向
                r = row - dir.dr;
                c = col - dir.dc;
                while (r >= 0 && r < 15 && c >= 0 && c < 15 && gameState.board[r][c] === player) {
                    count++;
                    r -= dir.dr;
                    c -= dir.dc;
                }
                
                if (count >= 5) {
                    return true;
                }
            }
            
            return false;
        }

        // 检查棋盘是否已满
        function isBoardFull() {
            for (let r = 0; r < 15; r++) {
                for (let c = 0; c < 15; c++) {
                    if (gameState.board[r][c] === 0) {
                        return false;
                    }
                }
            }
            return true;
        }

        // 更新棋盘显示（增强版，确保棋盘清晰可见）
        function updateBoardDisplay() {
            const cells = document.querySelectorAll('#board .cell');
            
            for (let r = 0; r < 15; r++) {
                for (let c = 0; c < 15; c++) {
                    const index = r * 15 + c;
                    const cell = cells[index];
                    cell.innerHTML = '';
                    cell.classList.remove('last-move');
                    
                    if (gameState.board[r][c] === 1) {
                        const piece = document.createElement('div');
                        piece.className = 'black';
                        cell.appendChild(piece);
                    } else if (gameState.board[r][c] === 2) {
                        const piece = document.createElement('div');
                        piece.className = 'white';
                        cell.appendChild(piece);
                    }
                    
                    if (gameState.lastMove && gameState.lastMove.row === r && gameState.lastMove.col === c) {
                        cell.classList.add('last-move');
                    }
                }
            }
        }

        // 显示调试信息
        function displayDebugInfo(scores, bestScore) {
            const debugInfo = document.getElementById('debugInfo');
            const aiThinking = document.getElementById('aiThinking');
            const scoreDetails = document.getElementById('scoreDetails');
            
            aiThinking.innerHTML = `
                <p>AI正在思考，评估了 ${scores.length} 个可能的位置</p>
                <p>最佳分数: ${bestScore.toFixed(1)}</p>
            `;
            
            scoreDetails.innerHTML = '';
            
            // 按总分排序
            scores.sort((a, b) => b.totalScore - a.totalScore);
            
            // 只显示前15个位置
            const displayCount = Math.min(15, scores.length);
            
            for (let i = 0; i < displayCount; i++) {
                const score = scores[i];
                const row = document.createElement('tr');
                
                if (i === 0) {
                    row.style.backgroundColor = '#e6f7e6';
                }
                
                row.innerHTML = `
                    <td>${score.position}</td>
                    <td>${score.offensiveScore.toFixed(1)}</td>
                    <td>${score.defensiveScore.toFixed(1)}</td>
                    <td>${score.totalScore.toFixed(1)}</td>
                    <td>${score.patterns}</td>
                `;
                
                scoreDetails.appendChild(row);
            }
        }

        // 添加命令行输出
        function addCommandOutput(message) {
            const output = document.getElementById('commandOutput');
            const entry = document.createElement('div');
            entry.textContent = message;
            output.appendChild(entry);
            output.scrollTop = output.scrollHeight;
        }

        // 处理命令行输入
        function handleCommandInput() {
            const input = document.getElementById('commandInput');
            const command = input.value.trim();
            input.value = '';
            
            if (!command) return;
            
            addCommandOutput(`> ${command}`);
            
            const parts = command.split(' ');
            const cmd = parts[0].toLowerCase();
            const args = parts.slice(1);
            
            try {
                if (cmd === 'goto' && args.length === 1) {
                    // 移动光标命令
                    const pos = parsePosition(args[0]);
                    if (pos) {
                        gameState.cursorPosition = pos;
                        updateCursorPosition();
                        addCommandOutput(`光标已移动到 ${args[0]}`);
                    } else {
                        addCommandOutput(`无效位置: ${args[0]}`);
                    }
                } else if (cmd === 'chess' && args.length === 1) {
                    // 落子命令
                    const pos = parsePosition(args[0]);
                    if (pos) {
                        if (gameState.board[pos.row][pos.col] === 0 || 
                            (gameState.currentPlayer === 1 && document.getElementById('firstPlayer').value === 'human')) {
                            // 允许命令行覆盖AI的棋子（如果是玩家回合）
                            makeMove(pos.row, pos.col, gameState.currentPlayer);
                            
                            if (!gameState.gameOver) {
                                setTimeout(() => aiMove(), 100);
                            }
                        } else {
                            addCommandOutput(`位置 ${args[0]} 已有棋子`);
                        }
                    } else {
                        addCommandOutput(`无效位置: ${args[0]}`);
                    }
                } else if (cmd === 'undo') {
                    // 悔棋命令
                    undoMove();
                    addCommandOutput(`已撤销上一步`);
                } else if (cmd === 'new') {
                    // 新游戏命令
                    newGame();
                    addCommandOutput(`开始新游戏`);
                } else if (cmd === 'help') {
                    // 帮助命令
                    addCommandOutput(`可用命令:
- goto <位置>: 移动光标到指定位置 (如: goto A1)
- chess <位置>: 在指定位置落子 (如: chess B2)
- undo: 撤销上一步
- new: 开始新游戏
- help: 显示帮助信息`);
                } else {
                    addCommandOutput(`未知命令: ${cmd}。输入 help 查看帮助`);
                }
            } catch (e) {
                addCommandOutput(`执行命令出错: ${e.message}`);
            }
        }

        // 保存学习数据
        function saveLearningData() {
            localStorage.setItem('gomokuLearningData', JSON.stringify(gameState.learningData));
        }

        // 清除学习数据
        function clearLearningData() {
            gameState.learningData = { 
                wins: [], 
                losses: [], 
                aiBattleStats: { ai1Wins: 0, ai2Wins: 0, draws: 0 },
                patternWeights: {
                    OPEN_FOUR: 10000,
                    HALF_OPEN_FOUR: 5000,
                    OPEN_THREE: 2000,
                    HALF_OPEN_THREE: 500,
                    OPEN_TWO: 200,
                    HALF_OPEN_TWO: 50,
                    OPEN_ONE: 10,
                    HALF_OPEN_ONE: 1
                },
                deepLearning: {}
            };
            
            // 更新PATTERNS中的权重
            PATTERNS.OPEN_FOUR.score = 10000;
            PATTERNS.HALF_OPEN_FOUR.score = 5000;
            PATTERNS.OPEN_THREE.score = 2000;
            PATTERNS.HALF_OPEN_THREE.score = 500;
            PATTERNS.OPEN_TWO.score = 200;
            PATTERNS.HALF_OPEN_TWO.score = 50;
            PATTERNS.OPEN_ONE.score = 10;
            PATTERNS.HALF_OPEN_ONE.score = 1;
            
            saveLearningData();
            updateAIBattleStats();
            addLogEntry('学习数据已清除', 'system');
            addCommandOutput('已清除所有学习数据');
        }

        // 新游戏
        function newGame() {
            if (gameState.isTraining || gameState.isAIBattle) return;
            
            // 应用选择的规则
            gameState.currentRule = document.getElementById('gameRule').value;
            gameState.swapAvailable = false;
            gameState.swapRequested = false;
            
            if (gameState.currentRule === 'custom') {
                document.getElementById('customRuleContainer').classList.remove('hidden');
            } else {
                document.getElementById('customRuleContainer').classList.add('hidden');
            }
            
            gameState.board = Array(15).fill().map(() => Array(15).fill(0));
            gameState.gameOver = false;
            gameState.lastMove = null;
            gameState.moveHistory = [];
            gameState.boardHistory = [];
            gameState.restrictedMoves = [];
            
            const firstPlayer = document.getElementById('firstPlayer').value;
            gameState.currentPlayer = firstPlayer === 'human' ? 1 : 2;
            
            document.getElementById('status').textContent = firstPlayer === 'human' ? '你的回合(黑棋)' : 'AI思考中...';
            updateBoardDisplay();
            updateMoveHistoryDisplay();
            
            // 应用初始规则限制
            applyRuleRestrictions(7, 7);
            
            if (firstPlayer === 'ai') {
                setTimeout(() => aiMove(), 300);
            }
        }

        // 开始AI训练
        function startTraining() {
            if (gameState.isTraining || gameState.isAIBattle) return;
            
            const games = parseInt(document.getElementById('trainGames').value);
            if (games < 1) return;
            
            gameState.isTraining = true;
            gameState.trainingQueue = games;
            document.getElementById('status').textContent = `AI训练中 (0/${games})`;
            
            // 禁用控制按钮
            document.getElementById('newGame').disabled = true;
            document.getElementById('startTraining').disabled = true;
            document.getElementById('startAIBattle').disabled = true;
            document.getElementById('undoMove').disabled = true;
            
            addCommandOutput(`开始AI训练，共 ${games} 局`);
            
            // 开始训练
            trainingStep();
        }

        // 训练步骤
        function trainingStep() {
            if (gameState.trainingQueue <= 0) {
                gameState.isTraining = false;
                document.getElementById('status').textContent = `训练完成 (${parseInt(document.getElementById('trainGames').value)}局)`;
                
                // 启用控制按钮
                document.getElementById('newGame').disabled = false;
                document.getElementById('startTraining').disabled = false;
                document.getElementById('startAIBattle').disabled = false;
                document.getElementById('undoMove').disabled = false;
                
                addCommandOutput(`AI训练完成，共 ${parseInt(document.getElementById('trainGames').value)} 局`);
                return;
            }
            
            // 设置训练游戏
            gameState.board = Array(15).fill().map(() => Array(15).fill(0));
            gameState.gameOver = false;
            gameState.lastMove = null;
            gameState.moveHistory = [];
            gameState.boardHistory = [];
            gameState.currentPlayer = Math.random() < 0.5 ? 1 : 2; // 随机先手
            
            // 更新状态
            const totalGames = parseInt(document.getElementById('trainGames').value);
            const completedGames = totalGames - gameState.trainingQueue;
            document.getElementById('status').textContent = `AI训练中 (${completedGames}/${totalGames})`;
            
            // 开始游戏
            if (gameState.currentPlayer === 2) {
                setTimeout(() => {
                    aiMove();
                    trainingNextStep();
                }, 10);
            } else {
                trainingNextStep();
            }
        }

        // 训练下一步
        function trainingNextStep() {
            if (!gameState.gameOver) {
                setTimeout(() => {
                    aiMove();
                    trainingNextStep();
                }, 10);
            } else {
                // 记录游戏结果
                if (gameState.lastMove) {
                    const winner = gameState.lastMove.player === 1 ? '黑棋' : '白棋';
                    addLogEntry(`训练局 ${parseInt(document.getElementById('trainGames').value) - gameState.trainingQueue + 1}: ${winner} 获胜`, 
                              gameState.lastMove.player === 1 ? 'loss' : 'win');
                } else {
                    addLogEntry(`训练局 ${parseInt(document.getElementById('trainGames').value) - gameState.trainingQueue + 1}: 平局`, 'draw');
                }
                
                gameState.trainingQueue--;
                setTimeout(trainingStep, 10);
            }
        }

        // 开始AI对战
        function startAIBattle() {
            if (gameState.isTraining || gameState.isAIBattle) return;
            
            const games = parseInt(document.getElementById('aiBattleGames').value);
            if (games < 1) return;
            
            gameState.isAIBattle = true;
            gameState.trainingQueue = games;
            gameState.aiBattlePlayers = [1, 2]; // 两个AI玩家
            document.getElementById('status').textContent = `AI对战中 (0/${games})`;
            
            // 禁用控制按钮
            document.getElementById('newGame').disabled = true;
            document.getElementById('startTraining').disabled = true;
            document.getElementById('startAIBattle').disabled = true;
            document.getElementById('undoMove').disabled = true;
            
            addCommandOutput(`开始AI对战，共 ${games} 局`);
            
            // 开始对战
            aiBattleStep();
        }

        // AI对战步骤
        function aiBattleStep() {
            if (gameState.trainingQueue <= 0) {
                gameState.isAIBattle = false;
                document.getElementById('status').textContent = `AI对战完成 (${parseInt(document.getElementById('aiBattleGames').value)}局)`;
                
                // 启用控制按钮
                document.getElementById('newGame').disabled = false;
                document.getElementById('startTraining').disabled = false;
                document.getElementById('startAIBattle').disabled = false;
                document.getElementById('undoMove').disabled = false;
                
                addCommandOutput(`AI对战完成，共 ${parseInt(document.getElementById('aiBattleGames').value)} 局`);
                return;
            }
            
            // 重置棋盘
            gameState.board = Array(15).fill().map(() => Array(15).fill(0));
            gameState.gameOver = false;
            gameState.lastMove = null;
            gameState.moveHistory = [];
            gameState.boardHistory = [];
            gameState.currentPlayer = Math.random() < 0.5 ? 1 : 2; // 随机先手
            
            // 更新状态
            const totalGames = parseInt(document.getElementById('aiBattleGames').value);
            const completedGames = totalGames - gameState.trainingQueue;
            document.getElementById('status').textContent = `AI对战中 (${completedGames}/${totalGames})`;
            updateBoardDisplay();
            
            addCommandOutput(`开始对战局 ${completedGames + 1}`);
            
            // 开始AI对战
            setTimeout(() => {
                aiMove();
            }, 100);
        }

        // 更新AI对战统计
        function updateAIBattleStats() {
            document.getElementById('ai1Wins').textContent = `AI1: ${gameState.learningData.aiBattleStats.ai1Wins}`;
            document.getElementById('ai2Wins').textContent = `AI2: ${gameState.learningData.aiBattleStats.ai2Wins}`;
            document.getElementById('aiDraws').textContent = `平局: ${gameState.learningData.aiBattleStats.draws}`;
        }

        // 添加日志条目
        function addLogEntry(message, type) {
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${type}`;
            logEntry.textContent = message;
            
            const logEntries = document.getElementById('logEntries');
            logEntries.insertBefore(logEntry, logEntries.firstChild);
            
            // 限制日志数量
            if (logEntries.children.length > 100) {
                logEntries.removeChild(logEntries.lastChild);
            }
        }

        // 初始化游戏
        function initGame() {
            initBoard();
            
            // 加载AI对战统计
            if (gameState.learningData.aiBattleStats) {
                updateAIBattleStats();
            }
            
            // 事件监听器
            document.getElementById('newGame').addEventListener('click', newGame);
            document.getElementById('undoMove').addEventListener('click', undoMove);
            document.getElementById('clearData').addEventListener('click', clearLearningData);
            document.getElementById('toggleDebug').addEventListener('click', () => {
                gameState.debugMode = !gameState.debugMode;
                document.getElementById('debugInfo').classList.toggle('hidden', !gameState.debugMode);
                document.getElementById('toggleDebug').textContent = gameState.debugMode ? '隐藏AI思考' : '显示AI思考';
            });
            document.getElementById('startTraining').addEventListener('click', startTraining);
            document.getElementById('startAIBattle').addEventListener('click', startAIBattle);
            document.getElementById('commandInput').addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    handleCommandInput();
                }
            });
            document.getElementById('gameRule').addEventListener('change', () => {
                if (document.getElementById('gameRule').value === 'custom') {
                    document.getElementById('customRuleContainer').classList.remove('hidden');
                } else {
                    document.getElementById('customRuleContainer').classList.add('hidden');
                }
            });
            
            // 初始游戏
            newGame();
            
            // 添加欢迎消息
            addCommandOutput('五子棋AI系统已启动');
            addCommandOutput('输入 help 查看可用命令');
        }

        // 启动游戏
        window.onload = initGame;
    </script>
</body>
</html>
